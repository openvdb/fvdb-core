{
    "name": "FVDB Development Environment",
    "dockerComposeFile": [
        "../docker-compose.yml"
    ],
    "service": "fvdb-dev",
    "workspaceFolder": "/openvdb/fvdb",

    "remoteUser": "coder",

    "features": {
        "ghcr.io/devcontainers/features/common-utils:2": {
            "username": "coder",
            "uid": "1001",
            "gid": "1001",
            "installSudo": true,
            "upgradePackages": true
        }
    },

    // Single source of truth for creating the dev environment.
    // We use 'bash -i -c' to ensure the shell is interactive, which properly
    // sources the .bashrc and activates conda before running the command.
    "postCreateCommand": "bash -i -c 'conda init bash && conda env create -f /openvdb/fvdb/env/dev_environment.yml && conda clean -afy && echo \"conda activate fvdb\" >> ~/.bashrc'",

    // This runs after you connect, good for user-specific setup like SSH.
    "postAttachCommand": "rm -rf ~/.ssh && ln -sfn /tmp/.ssh-localhost ~/.ssh",

    // This mounts the host's .ssh directory to a generic location inside the container.
    // We will then symlink it in the postCreateCommand.
    "mounts": [
        "source=${localEnv:HOME}/.ssh,target=/tmp/.ssh-localhost,type=bind,readonly"
    ],

    // Extensions to install inside the container's VS Code server
    "customizations": {
        "vscode": {
            "extensions": [
                "ms-python.python",
                "ms-vscode.cpptools",
                "ms-vscode.cmake-tools",
                "ms-azuretools.vscode-docker"
            ],
            "settings": {
                "python.defaultInterpreterPath": "/opt/conda/envs/fvdb/bin/python"
            }
        }
    },

    "shutdownAction": "stopCompose"
}

